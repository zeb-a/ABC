{"version":3,"file":"size-rollup-waapi-animate.js","sources":["../../motion-utils/dist/es/errors.mjs","../../motion-utils/dist/es/memo.mjs","../../motion-utils/dist/es/format-error-message.mjs","../../motion-utils/dist/es/noop.mjs","../../motion-utils/dist/es/time-conversion.mjs","../../motion-dom/dist/es/animation/keyframes/get-final.mjs","../../motion-dom/dist/es/animation/utils/WithPromise.mjs","../../motion-dom/dist/es/animation/keyframes/utils/fill-wildcards.mjs","../../motion-dom/dist/es/render/dom/is-css-var.mjs","../../motion-dom/dist/es/utils/supports/scroll-timeline.mjs","../../motion-dom/dist/es/utils/supports/flags.mjs","../../motion-dom/dist/es/utils/supports/memo.mjs","../../motion-dom/dist/es/utils/supports/linear-easing.mjs","../../motion-dom/dist/es/animation/waapi/easing/cubic-bezier.mjs","../../motion-dom/dist/es/animation/waapi/easing/supported.mjs","../../motion-dom/dist/es/animation/waapi/easing/map-easing.mjs","../../motion-dom/dist/es/animation/waapi/utils/linear.mjs","../../motion-utils/dist/es/easing/utils/is-bezier-definition.mjs","../../motion-dom/dist/es/animation/NativeAnimation.mjs","../../motion-dom/dist/es/animation/waapi/utils/apply-generator.mjs","../../motion-dom/dist/es/animation/generators/utils/is-generator.mjs","../../motion-dom/dist/es/animation/waapi/start-waapi-animation.mjs","../../motion-dom/dist/es/render/dom/style-set.mjs","../../motion-dom/dist/es/animation/GroupAnimation.mjs","../../motion-dom/dist/es/animation/GroupAnimationWithThen.mjs","../../motion-dom/dist/es/animation/utils/active-animations.mjs","../../motion-dom/dist/es/animation/utils/get-value-transition.mjs","../../motion-dom/dist/es/animation/waapi/utils/px-values.mjs","../../motion-dom/dist/es/animation/keyframes/utils/apply-px-defaults.mjs","../../motion-dom/dist/es/render/dom/style-computed.mjs","../lib/animation/animators/waapi/animate-elements.js","../../motion-dom/dist/es/utils/resolve-elements.mjs","../lib/animation/animators/waapi/animate-style.js"],"sourcesContent":["import { formatErrorMessage } from './format-error-message.mjs';\n\nlet warning = () => { };\nlet invariant = () => { };\nif (typeof process !== \"undefined\" &&\n    process.env?.NODE_ENV !== \"production\") {\n    warning = (check, message, errorCode) => {\n        if (!check && typeof console !== \"undefined\") {\n            console.warn(formatErrorMessage(message, errorCode));\n        }\n    };\n    invariant = (check, message, errorCode) => {\n        if (!check) {\n            throw new Error(formatErrorMessage(message, errorCode));\n        }\n    };\n}\n\nexport { invariant, warning };\n","/*#__NO_SIDE_EFFECTS__*/\nfunction memo(callback) {\n    let result;\n    return () => {\n        if (result === undefined)\n            result = callback();\n        return result;\n    };\n}\n\nexport { memo };\n","function formatErrorMessage(message, errorCode) {\n    return errorCode\n        ? `${message}. For more information and steps for solving, visit https://motion.dev/troubleshooting/${errorCode}`\n        : message;\n}\n\nexport { formatErrorMessage };\n","/*#__NO_SIDE_EFFECTS__*/\nconst noop = (any) => any;\n\nexport { noop };\n","/**\n * Converts seconds to milliseconds\n *\n * @param seconds - Time in seconds.\n * @return milliseconds - Converted time in milliseconds.\n */\n/*#__NO_SIDE_EFFECTS__*/\nconst secondsToMilliseconds = (seconds) => seconds * 1000;\n/*#__NO_SIDE_EFFECTS__*/\nconst millisecondsToSeconds = (milliseconds) => milliseconds / 1000;\n\nexport { millisecondsToSeconds, secondsToMilliseconds };\n","const isNotNull = (value) => value !== null;\nfunction getFinalKeyframe(keyframes, { repeat, repeatType = \"loop\" }, finalKeyframe, speed = 1) {\n    const resolvedKeyframes = keyframes.filter(isNotNull);\n    const useFirstKeyframe = speed < 0 || (repeat && repeatType !== \"loop\" && repeat % 2 === 1);\n    const index = useFirstKeyframe ? 0 : resolvedKeyframes.length - 1;\n    return !index || finalKeyframe === undefined\n        ? resolvedKeyframes[index]\n        : finalKeyframe;\n}\n\nexport { getFinalKeyframe };\n","class WithPromise {\n    constructor() {\n        this.updateFinished();\n    }\n    get finished() {\n        return this._finished;\n    }\n    updateFinished() {\n        this._finished = new Promise((resolve) => {\n            this.resolve = resolve;\n        });\n    }\n    notifyFinished() {\n        this.resolve();\n    }\n    /**\n     * Allows the animation to be awaited.\n     *\n     * @deprecated Use `finished` instead.\n     */\n    then(onResolve, onReject) {\n        return this.finished.then(onResolve, onReject);\n    }\n}\n\nexport { WithPromise };\n","function fillWildcards(keyframes) {\n    for (let i = 1; i < keyframes.length; i++) {\n        keyframes[i] ?? (keyframes[i] = keyframes[i - 1]);\n    }\n}\n\nexport { fillWildcards };\n","const isCSSVar = (name) => name.startsWith(\"--\");\n\nexport { isCSSVar };\n","import { memo } from 'motion-utils';\n\nconst supportsScrollTimeline = /* @__PURE__ */ memo(() => window.ScrollTimeline !== undefined);\n\nexport { supportsScrollTimeline };\n","/**\n * Add the ability for test suites to manually set support flags\n * to better test more environments.\n */\nconst supportsFlags = {};\n\nexport { supportsFlags };\n","import { memo } from 'motion-utils';\nimport { supportsFlags } from './flags.mjs';\n\nfunction memoSupports(callback, supportsFlag) {\n    const memoized = memo(callback);\n    return () => supportsFlags[supportsFlag] ?? memoized();\n}\n\nexport { memoSupports };\n","import { memoSupports } from './memo.mjs';\n\nconst supportsLinearEasing = /*@__PURE__*/ memoSupports(() => {\n    try {\n        document\n            .createElement(\"div\")\n            .animate({ opacity: 0 }, { easing: \"linear(0, 1)\" });\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n}, \"linearEasing\");\n\nexport { supportsLinearEasing };\n","const cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;\n\nexport { cubicBezierAsString };\n","import { cubicBezierAsString } from './cubic-bezier.mjs';\n\nconst supportedWaapiEasing = {\n    linear: \"linear\",\n    ease: \"ease\",\n    easeIn: \"ease-in\",\n    easeOut: \"ease-out\",\n    easeInOut: \"ease-in-out\",\n    circIn: /*@__PURE__*/ cubicBezierAsString([0, 0.65, 0.55, 1]),\n    circOut: /*@__PURE__*/ cubicBezierAsString([0.55, 0, 1, 0.45]),\n    backIn: /*@__PURE__*/ cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),\n    backOut: /*@__PURE__*/ cubicBezierAsString([0.33, 1.53, 0.69, 0.99]),\n};\n\nexport { supportedWaapiEasing };\n","import { isBezierDefinition } from 'motion-utils';\nimport { supportsLinearEasing } from '../../../utils/supports/linear-easing.mjs';\nimport { generateLinearEasing } from '../utils/linear.mjs';\nimport { cubicBezierAsString } from './cubic-bezier.mjs';\nimport { supportedWaapiEasing } from './supported.mjs';\n\nfunction mapEasingToNativeEasing(easing, duration) {\n    if (!easing) {\n        return undefined;\n    }\n    else if (typeof easing === \"function\") {\n        return supportsLinearEasing()\n            ? generateLinearEasing(easing, duration)\n            : \"ease-out\";\n    }\n    else if (isBezierDefinition(easing)) {\n        return cubicBezierAsString(easing);\n    }\n    else if (Array.isArray(easing)) {\n        return easing.map((segmentEasing) => mapEasingToNativeEasing(segmentEasing, duration) ||\n            supportedWaapiEasing.easeOut);\n    }\n    else {\n        return supportedWaapiEasing[easing];\n    }\n}\n\nexport { mapEasingToNativeEasing };\n","const generateLinearEasing = (easing, duration, // as milliseconds\nresolution = 10 // as milliseconds\n) => {\n    let points = \"\";\n    const numPoints = Math.max(Math.round(duration / resolution), 2);\n    for (let i = 0; i < numPoints; i++) {\n        points += Math.round(easing(i / (numPoints - 1)) * 10000) / 10000 + \", \";\n    }\n    return `linear(${points.substring(0, points.length - 2)})`;\n};\n\nexport { generateLinearEasing };\n","const isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === \"number\";\n\nexport { isBezierDefinition };\n","import { invariant, millisecondsToSeconds, secondsToMilliseconds, noop } from 'motion-utils';\nimport { setStyle } from '../render/dom/style-set.mjs';\nimport { supportsScrollTimeline } from '../utils/supports/scroll-timeline.mjs';\nimport { getFinalKeyframe } from './keyframes/get-final.mjs';\nimport { WithPromise } from './utils/WithPromise.mjs';\nimport { startWaapiAnimation } from './waapi/start-waapi-animation.mjs';\nimport { applyGeneratorOptions } from './waapi/utils/apply-generator.mjs';\n\n/**\n * NativeAnimation implements AnimationPlaybackControls for the browser's Web Animations API.\n */\nclass NativeAnimation extends WithPromise {\n    constructor(options) {\n        super();\n        this.finishedTime = null;\n        this.isStopped = false;\n        if (!options)\n            return;\n        const { element, name, keyframes, pseudoElement, allowFlatten = false, finalKeyframe, onComplete, } = options;\n        this.isPseudoElement = Boolean(pseudoElement);\n        this.allowFlatten = allowFlatten;\n        this.options = options;\n        invariant(typeof options.type !== \"string\", `Mini animate() doesn't support \"type\" as a string.`, \"mini-spring\");\n        const transition = applyGeneratorOptions(options);\n        this.animation = startWaapiAnimation(element, name, keyframes, transition, pseudoElement);\n        if (transition.autoplay === false) {\n            this.animation.pause();\n        }\n        this.animation.onfinish = () => {\n            this.finishedTime = this.time;\n            if (!pseudoElement) {\n                const keyframe = getFinalKeyframe(keyframes, this.options, finalKeyframe, this.speed);\n                if (this.updateMotionValue) {\n                    this.updateMotionValue(keyframe);\n                }\n                else {\n                    /**\n                     * If we can, we want to commit the final style as set by the user,\n                     * rather than the computed keyframe value supplied by the animation.\n                     */\n                    setStyle(element, name, keyframe);\n                }\n                this.animation.cancel();\n            }\n            onComplete?.();\n            this.notifyFinished();\n        };\n    }\n    play() {\n        if (this.isStopped)\n            return;\n        this.animation.play();\n        if (this.state === \"finished\") {\n            this.updateFinished();\n        }\n    }\n    pause() {\n        this.animation.pause();\n    }\n    complete() {\n        this.animation.finish?.();\n    }\n    cancel() {\n        try {\n            this.animation.cancel();\n        }\n        catch (e) { }\n    }\n    stop() {\n        if (this.isStopped)\n            return;\n        this.isStopped = true;\n        const { state } = this;\n        if (state === \"idle\" || state === \"finished\") {\n            return;\n        }\n        if (this.updateMotionValue) {\n            this.updateMotionValue();\n        }\n        else {\n            this.commitStyles();\n        }\n        if (!this.isPseudoElement)\n            this.cancel();\n    }\n    /**\n     * WAAPI doesn't natively have any interruption capabilities.\n     *\n     * In this method, we commit styles back to the DOM before cancelling\n     * the animation.\n     *\n     * This is designed to be overridden by NativeAnimationExtended, which\n     * will create a renderless JS animation and sample it twice to calculate\n     * its current value, \"previous\" value, and therefore allow\n     * Motion to also correctly calculate velocity for any subsequent animation\n     * while deferring the commit until the next animation frame.\n     */\n    commitStyles() {\n        if (!this.isPseudoElement) {\n            this.animation.commitStyles?.();\n        }\n    }\n    get duration() {\n        const duration = this.animation.effect?.getComputedTiming?.().duration || 0;\n        return millisecondsToSeconds(Number(duration));\n    }\n    get iterationDuration() {\n        const { delay = 0 } = this.options || {};\n        return this.duration + millisecondsToSeconds(delay);\n    }\n    get time() {\n        return millisecondsToSeconds(Number(this.animation.currentTime) || 0);\n    }\n    set time(newTime) {\n        this.finishedTime = null;\n        this.animation.currentTime = secondsToMilliseconds(newTime);\n    }\n    /**\n     * The playback speed of the animation.\n     * 1 = normal speed, 2 = double speed, 0.5 = half speed.\n     */\n    get speed() {\n        return this.animation.playbackRate;\n    }\n    set speed(newSpeed) {\n        // Allow backwards playback after finishing\n        if (newSpeed < 0)\n            this.finishedTime = null;\n        this.animation.playbackRate = newSpeed;\n    }\n    get state() {\n        return this.finishedTime !== null\n            ? \"finished\"\n            : this.animation.playState;\n    }\n    get startTime() {\n        return Number(this.animation.startTime);\n    }\n    set startTime(newStartTime) {\n        this.animation.startTime = newStartTime;\n    }\n    /**\n     * Attaches a timeline to the animation, for instance the `ScrollTimeline`.\n     */\n    attachTimeline({ timeline, observe }) {\n        if (this.allowFlatten) {\n            this.animation.effect?.updateTiming({ easing: \"linear\" });\n        }\n        this.animation.onfinish = null;\n        if (timeline && supportsScrollTimeline()) {\n            this.animation.timeline = timeline;\n            return noop;\n        }\n        else {\n            return observe(this);\n        }\n    }\n}\n\nexport { NativeAnimation };\n","import { supportsLinearEasing } from '../../../utils/supports/linear-easing.mjs';\nimport { isGenerator } from '../../generators/utils/is-generator.mjs';\n\nfunction applyGeneratorOptions({ type, ...options }) {\n    if (isGenerator(type) && supportsLinearEasing()) {\n        return type.applyToOptions(options);\n    }\n    else {\n        options.duration ?? (options.duration = 300);\n        options.ease ?? (options.ease = \"easeOut\");\n    }\n    return options;\n}\n\nexport { applyGeneratorOptions };\n","function isGenerator(type) {\n    return typeof type === \"function\" && \"applyToOptions\" in type;\n}\n\nexport { isGenerator };\n","import { activeAnimations } from '../../stats/animation-count.mjs';\nimport { statsBuffer } from '../../stats/buffer.mjs';\nimport { mapEasingToNativeEasing } from './easing/map-easing.mjs';\n\nfunction startWaapiAnimation(element, valueName, keyframes, { delay = 0, duration = 300, repeat = 0, repeatType = \"loop\", ease = \"easeOut\", times, } = {}, pseudoElement = undefined) {\n    const keyframeOptions = {\n        [valueName]: keyframes,\n    };\n    if (times)\n        keyframeOptions.offset = times;\n    const easing = mapEasingToNativeEasing(ease, duration);\n    /**\n     * If this is an easing array, apply to keyframes, not animation as a whole\n     */\n    if (Array.isArray(easing))\n        keyframeOptions.easing = easing;\n    if (statsBuffer.value) {\n        activeAnimations.waapi++;\n    }\n    const options = {\n        delay,\n        duration,\n        easing: !Array.isArray(easing) ? easing : \"linear\",\n        fill: \"both\",\n        iterations: repeat + 1,\n        direction: repeatType === \"reverse\" ? \"alternate\" : \"normal\",\n    };\n    if (pseudoElement)\n        options.pseudoElement = pseudoElement;\n    const animation = element.animate(keyframeOptions, options);\n    if (statsBuffer.value) {\n        animation.finished.finally(() => {\n            activeAnimations.waapi--;\n        });\n    }\n    return animation;\n}\n\nexport { startWaapiAnimation };\n","import { isCSSVar } from './is-css-var.mjs';\n\nfunction setStyle(element, name, value) {\n    isCSSVar(name)\n        ? element.style.setProperty(name, value)\n        : (element.style[name] = value);\n}\n\nexport { setStyle };\n","class GroupAnimation {\n    constructor(animations) {\n        // Bound to accomadate common `return animation.stop` pattern\n        this.stop = () => this.runAll(\"stop\");\n        this.animations = animations.filter(Boolean);\n    }\n    get finished() {\n        return Promise.all(this.animations.map((animation) => animation.finished));\n    }\n    /**\n     * TODO: Filter out cancelled or stopped animations before returning\n     */\n    getAll(propName) {\n        return this.animations[0][propName];\n    }\n    setAll(propName, newValue) {\n        for (let i = 0; i < this.animations.length; i++) {\n            this.animations[i][propName] = newValue;\n        }\n    }\n    attachTimeline(timeline) {\n        const subscriptions = this.animations.map((animation) => animation.attachTimeline(timeline));\n        return () => {\n            subscriptions.forEach((cancel, i) => {\n                cancel && cancel();\n                this.animations[i].stop();\n            });\n        };\n    }\n    get time() {\n        return this.getAll(\"time\");\n    }\n    set time(time) {\n        this.setAll(\"time\", time);\n    }\n    get speed() {\n        return this.getAll(\"speed\");\n    }\n    set speed(speed) {\n        this.setAll(\"speed\", speed);\n    }\n    get state() {\n        return this.getAll(\"state\");\n    }\n    get startTime() {\n        return this.getAll(\"startTime\");\n    }\n    get duration() {\n        return getMax(this.animations, \"duration\");\n    }\n    get iterationDuration() {\n        return getMax(this.animations, \"iterationDuration\");\n    }\n    runAll(methodName) {\n        this.animations.forEach((controls) => controls[methodName]());\n    }\n    play() {\n        this.runAll(\"play\");\n    }\n    pause() {\n        this.runAll(\"pause\");\n    }\n    cancel() {\n        this.runAll(\"cancel\");\n    }\n    complete() {\n        this.runAll(\"complete\");\n    }\n}\nfunction getMax(animations, propName) {\n    let max = 0;\n    for (let i = 0; i < animations.length; i++) {\n        const value = animations[i][propName];\n        if (value !== null && value > max) {\n            max = value;\n        }\n    }\n    return max;\n}\n\nexport { GroupAnimation };\n","import { GroupAnimation } from './GroupAnimation.mjs';\n\nclass GroupAnimationWithThen extends GroupAnimation {\n    then(onResolve, _onReject) {\n        return this.finished.finally(onResolve).then(() => { });\n    }\n}\n\nexport { GroupAnimationWithThen };\n","const animationMaps = new WeakMap();\nconst animationMapKey = (name, pseudoElement = \"\") => `${name}:${pseudoElement}`;\nfunction getAnimationMap(element) {\n    const map = animationMaps.get(element) || new Map();\n    animationMaps.set(element, map);\n    return map;\n}\n\nexport { animationMapKey, getAnimationMap };\n","function getValueTransition(transition, key) {\n    return (transition?.[key] ??\n        transition?.[\"default\"] ??\n        transition);\n}\n\nexport { getValueTransition };\n","const pxValues = new Set([\n    // Border props\n    \"borderWidth\",\n    \"borderTopWidth\",\n    \"borderRightWidth\",\n    \"borderBottomWidth\",\n    \"borderLeftWidth\",\n    \"borderRadius\",\n    \"radius\",\n    \"borderTopLeftRadius\",\n    \"borderTopRightRadius\",\n    \"borderBottomRightRadius\",\n    \"borderBottomLeftRadius\",\n    // Positioning props\n    \"width\",\n    \"maxWidth\",\n    \"height\",\n    \"maxHeight\",\n    \"top\",\n    \"right\",\n    \"bottom\",\n    \"left\",\n    \"inset\",\n    \"insetBlock\",\n    \"insetBlockStart\",\n    \"insetBlockEnd\",\n    \"insetInline\",\n    \"insetInlineStart\",\n    \"insetInlineEnd\",\n    // Spacing props\n    \"padding\",\n    \"paddingTop\",\n    \"paddingRight\",\n    \"paddingBottom\",\n    \"paddingLeft\",\n    \"paddingBlock\",\n    \"paddingBlockStart\",\n    \"paddingBlockEnd\",\n    \"paddingInline\",\n    \"paddingInlineStart\",\n    \"paddingInlineEnd\",\n    \"margin\",\n    \"marginTop\",\n    \"marginRight\",\n    \"marginBottom\",\n    \"marginLeft\",\n    \"marginBlock\",\n    \"marginBlockStart\",\n    \"marginBlockEnd\",\n    \"marginInline\",\n    \"marginInlineStart\",\n    \"marginInlineEnd\",\n    // Misc\n    \"backgroundPositionX\",\n    \"backgroundPositionY\",\n]);\n\nexport { pxValues };\n","import { pxValues } from '../../waapi/utils/px-values.mjs';\n\nfunction applyPxDefaults(keyframes, name) {\n    for (let i = 0; i < keyframes.length; i++) {\n        if (typeof keyframes[i] === \"number\" && pxValues.has(name)) {\n            keyframes[i] = keyframes[i] + \"px\";\n        }\n    }\n}\n\nexport { applyPxDefaults };\n","import { isCSSVar } from './is-css-var.mjs';\n\nfunction getComputedStyle(element, name) {\n    const computedStyle = window.getComputedStyle(element);\n    return isCSSVar(name)\n        ? computedStyle.getPropertyValue(name)\n        : computedStyle[name];\n}\n\nexport { getComputedStyle };\n","import { animationMapKey, applyPxDefaults, fillWildcards, getAnimationMap, getComputedStyle, getValueTransition, NativeAnimation, resolveElements, } from \"motion-dom\";\nimport { invariant, secondsToMilliseconds } from \"motion-utils\";\nexport function animateElements(elementOrSelector, keyframes, options, scope) {\n    const elements = resolveElements(elementOrSelector, scope);\n    const numElements = elements.length;\n    invariant(Boolean(numElements), \"No valid elements provided.\", \"no-valid-elements\");\n    /**\n     * WAAPI doesn't support interrupting animations.\n     *\n     * Therefore, starting animations requires a three-step process:\n     * 1. Stop existing animations (write styles to DOM)\n     * 2. Resolve keyframes (read styles from DOM)\n     * 3. Create new animations (write styles to DOM)\n     *\n     * The hybrid `animate()` function uses AsyncAnimation to resolve\n     * keyframes before creating new animations, which removes style\n     * thrashing. Here, we have much stricter filesize constraints.\n     * Therefore we do this in a synchronous way that ensures that\n     * at least within `animate()` calls there is no style thrashing.\n     *\n     * In the motion-native-animate-mini-interrupt benchmark this\n     * was 80% faster than a single loop.\n     */\n    const animationDefinitions = [];\n    /**\n     * Step 1: Build options and stop existing animations (write)\n     */\n    for (let i = 0; i < numElements; i++) {\n        const element = elements[i];\n        const elementTransition = { ...options };\n        /**\n         * Resolve stagger function if provided.\n         */\n        if (typeof elementTransition.delay === \"function\") {\n            elementTransition.delay = elementTransition.delay(i, numElements);\n        }\n        for (const valueName in keyframes) {\n            let valueKeyframes = keyframes[valueName];\n            if (!Array.isArray(valueKeyframes)) {\n                valueKeyframes = [valueKeyframes];\n            }\n            const valueOptions = {\n                ...getValueTransition(elementTransition, valueName),\n            };\n            valueOptions.duration && (valueOptions.duration = secondsToMilliseconds(valueOptions.duration));\n            valueOptions.delay && (valueOptions.delay = secondsToMilliseconds(valueOptions.delay));\n            /**\n             * If there's an existing animation playing on this element then stop it\n             * before creating a new one.\n             */\n            const map = getAnimationMap(element);\n            const key = animationMapKey(valueName, valueOptions.pseudoElement || \"\");\n            const currentAnimation = map.get(key);\n            currentAnimation && currentAnimation.stop();\n            animationDefinitions.push({\n                map,\n                key,\n                unresolvedKeyframes: valueKeyframes,\n                options: {\n                    ...valueOptions,\n                    element,\n                    name: valueName,\n                    allowFlatten: !elementTransition.type && !elementTransition.ease,\n                },\n            });\n        }\n    }\n    /**\n     * Step 2: Resolve keyframes (read)\n     */\n    for (let i = 0; i < animationDefinitions.length; i++) {\n        const { unresolvedKeyframes, options: animationOptions } = animationDefinitions[i];\n        const { element, name, pseudoElement } = animationOptions;\n        if (!pseudoElement && unresolvedKeyframes[0] === null) {\n            unresolvedKeyframes[0] = getComputedStyle(element, name);\n        }\n        fillWildcards(unresolvedKeyframes);\n        applyPxDefaults(unresolvedKeyframes, name);\n        /**\n         * If we only have one keyframe, explicitly read the initial keyframe\n         * from the computed style. This is to ensure consistency with WAAPI behaviour\n         * for restarting animations, for instance .play() after finish, when it\n         * has one vs two keyframes.\n         */\n        if (!pseudoElement && unresolvedKeyframes.length < 2) {\n            unresolvedKeyframes.unshift(getComputedStyle(element, name));\n        }\n        animationOptions.keyframes = unresolvedKeyframes;\n    }\n    /**\n     * Step 3: Create new animations (write)\n     */\n    const animations = [];\n    for (let i = 0; i < animationDefinitions.length; i++) {\n        const { map, key, options: animationOptions } = animationDefinitions[i];\n        const animation = new NativeAnimation(animationOptions);\n        map.set(key, animation);\n        animation.finished.finally(() => map.delete(key));\n        animations.push(animation);\n    }\n    return animations;\n}\n//# sourceMappingURL=animate-elements.js.map","function resolveElements(elementOrSelector, scope, selectorCache) {\n    if (elementOrSelector instanceof EventTarget) {\n        return [elementOrSelector];\n    }\n    else if (typeof elementOrSelector === \"string\") {\n        let root = document;\n        if (scope) {\n            root = scope.current;\n        }\n        const elements = selectorCache?.[elementOrSelector] ??\n            root.querySelectorAll(elementOrSelector);\n        return elements ? Array.from(elements) : [];\n    }\n    return Array.from(elementOrSelector);\n}\n\nexport { resolveElements };\n","import { GroupAnimationWithThen, } from \"motion-dom\";\nimport { animateElements } from \"./animate-elements\";\nexport const createScopedWaapiAnimate = (scope) => {\n    function scopedAnimate(elementOrSelector, keyframes, options) {\n        return new GroupAnimationWithThen(animateElements(elementOrSelector, keyframes, options, scope));\n    }\n    return scopedAnimate;\n};\nexport const animateMini = /*@__PURE__*/ createScopedWaapiAnimate();\n//# sourceMappingURL=animate-style.js.map"],"names":["invariant","memo","callback","result","undefined","process","env","NODE_ENV","check","message","errorCode","Error","formatErrorMessage","noop","any","secondsToMilliseconds","seconds","millisecondsToSeconds","milliseconds","isNotNull","value","WithPromise","constructor","this","updateFinished","finished","_finished","Promise","resolve","notifyFinished","then","onResolve","onReject","fillWildcards","keyframes","i","length","isCSSVar","name","startsWith","supportsScrollTimeline","window","ScrollTimeline","supportsFlags","memoSupports","supportsFlag","memoized","supportsLinearEasing","document","createElement","animate","opacity","easing","e","cubicBezierAsString","a","b","c","d","supportedWaapiEasing","linear","ease","easeIn","easeOut","easeInOut","circIn","circOut","backIn","backOut","mapEasingToNativeEasing","duration","resolution","points","numPoints","Math","max","round","substring","generateLinearEasing","Array","isArray","isBezierDefinition","map","segmentEasing","NativeAnimation","options","super","finishedTime","isStopped","element","pseudoElement","allowFlatten","finalKeyframe","onComplete","isPseudoElement","Boolean","type","transition","isGenerator","applyToOptions","applyGeneratorOptions","animation","valueName","delay","repeat","repeatType","times","keyframeOptions","offset","fill","iterations","direction","startWaapiAnimation","autoplay","pause","onfinish","time","keyframe","speed","resolvedKeyframes","filter","index","getFinalKeyframe","updateMotionValue","style","setProperty","setStyle","cancel","play","state","complete","finish","stop","commitStyles","effect","getComputedTiming","Number","iterationDuration","currentTime","newTime","playbackRate","newSpeed","playState","startTime","newStartTime","attachTimeline","timeline","observe","updateTiming","GroupAnimation","animations","runAll","all","getAll","propName","setAll","newValue","subscriptions","forEach","getMax","methodName","controls","GroupAnimationWithThen","_onReject","finally","animationMaps","WeakMap","animationMapKey","getAnimationMap","get","Map","set","getValueTransition","key","pxValues","Set","applyPxDefaults","has","getComputedStyle","computedStyle","getPropertyValue","animateElements","elementOrSelector","scope","elements","EventTarget","root","current","querySelectorAll","from","resolveElements","numElements","animationDefinitions","elementTransition","valueKeyframes","valueOptions","currentAnimation","push","unresolvedKeyframes","animationOptions","unshift","delete","createScopedWaapiAnimate","animateMini"],"mappings":"AAGA,IAAIA,EAAY,OCFhB,SAASC,EAAKC,GACV,IAAIC,EACJ,MAAO,UACYC,IAAXD,IACAA,EAASD,KACNC,EAEf,CDJuB,oBAAZE,SACmB,eAA1BA,QAAQC,KAAKC,WAMbP,EAAY,CAACQ,EAAOC,EAASC,KACzB,IAAKF,EACD,MAAM,IAAIG,MEbtB,SAA4BF,EAASC,GACjC,OAAOA,EACD,GAAGD,2FAAiGC,IACpGD,CACV,CFS4BG,CAAmBH,EAASC,MGZxD,MAAMG,EAAQC,GAAQA,ECMhBC,EAAyBC,GAAsB,IAAVA,EAErCC,EAAyBC,GAAiBA,EAAe,ICTzDC,EAAaC,GAAoB,OAAVA,ECA7B,MAAMC,EACF,WAAAC,GACIC,KAAKC,gBACR,CACD,YAAIC,GACA,OAAOF,KAAKG,SACf,CACD,cAAAF,GACID,KAAKG,UAAY,IAAIC,QAASC,IAC1BL,KAAKK,QAAUA,GAEtB,CACD,cAAAC,GACIN,KAAKK,SACR,CAMD,IAAAE,CAAKC,EAAWC,GACZ,OAAOT,KAAKE,SAASK,KAAKC,EAAWC,EACxC,ECtBL,SAASC,EAAcC,GACnB,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAUE,OAAQD,IAClCD,EAAUC,KAAOD,EAAUC,GAAKD,EAAUC,EAAI,GAEtD,CCJA,MAAME,EAAYC,GAASA,EAAKC,WAAW,MCE3C,MAAMC,EAAyCvC,EAAK,SAAgCG,IAA1BqC,OAAOC,gBCE3DC,EAAgB,CAAE,ECDxB,SAASC,EAAa1C,EAAU2C,GAC5B,MAAMC,EAAW7C,EAAKC,GACtB,MAAO,IAAMyC,EAAcE,IAAiBC,GAChD,CCJA,MAAMC,EAAqCH,EAAa,KACpD,IACII,SACKC,cAAc,OACdC,QAAQ,CAAEC,QAAS,GAAK,CAAEC,OAAQ,gBAC1C,CACD,MAAOC,GACH,OAAO,CACV,CACD,OAAO,GACR,gBCZGC,EAAsB,EAAEC,EAAGC,EAAGC,EAAGC,KAAO,gBAAgBH,MAAMC,MAAMC,MAAMC,KCE1EC,EAAuB,CACzBC,OAAQ,SACRC,KAAM,OACNC,OAAQ,UACRC,QAAS,WACTC,UAAW,cACXC,OAAsBX,EAAoB,CAAC,EAAG,IAAM,IAAM,IAC1DY,QAAuBZ,EAAoB,CAAC,IAAM,EAAG,EAAG,MACxDa,OAAsBb,EAAoB,CAAC,IAAM,IAAM,KAAO,MAC9Dc,QAAuBd,EAAoB,CAAC,IAAM,KAAM,IAAM,OCLlE,SAASe,EAAwBjB,EAAQkB,GACrC,OAAKlB,EAGsB,mBAAXA,EACLL,ICXc,EAACK,EAAQkB,EACtCC,EAAa,MAET,IAAIC,EAAS,GACb,MAAMC,EAAYC,KAAKC,IAAID,KAAKE,MAAMN,EAAWC,GAAa,GAC9D,IAAK,IAAIpC,EAAI,EAAGA,EAAIsC,EAAWtC,IAC3BqC,GAAUE,KAAKE,MAAoC,IAA9BxB,EAAOjB,GAAKsC,EAAY,KAAe,IAAQ,KAExE,MAAO,UAAUD,EAAOK,UAAU,EAAGL,EAAOpC,OAAS,ODI3C0C,CAAqB1B,EAAQkB,GAC7B,WEba,CAAClB,GAAW2B,MAAMC,QAAQ5B,IAAgC,iBAAdA,EAAO,GFejE6B,CAAmB7B,GACjBE,EAAoBF,GAEtB2B,MAAMC,QAAQ5B,GACZA,EAAO8B,IAAKC,GAAkBd,EAAwBc,EAAeb,IACxEX,EAAqBI,SAGlBJ,EAAqBP,QAf5B,CAiBR,CGdA,MAAMgC,UAAwB/D,EAC1B,WAAAC,CAAY+D,GAIR,GAHAC,QACA/D,KAAKgE,aAAe,KACpBhE,KAAKiE,WAAY,GACZH,EACD,OACJ,MAAMI,QAAEA,EAAOnD,KAAEA,EAAIJ,UAAEA,EAASwD,cAAEA,EAAaC,aAAEA,GAAe,EAAKC,cAAEA,EAAaC,WAAEA,GAAgBR,EACtG9D,KAAKuE,gBAAkBC,QAAQL,GAC/BnE,KAAKoE,aAAeA,EACpBpE,KAAK8D,QAAUA,EACfrF,EAAkC,iBAAjBqF,EAAQW,KAAmB,sDAAsD,eAClG,MAAMC,ECpBd,UAA+BD,KAAEA,KAASX,IACtC,OCJJ,SAAqBW,GACjB,MAAuB,mBAATA,GAAuB,mBAAoBA,CAC7D,CDEQE,CAAYF,IAASjD,IACdiD,EAAKG,eAAed,IAG3BA,EAAQf,WAAae,EAAQf,SAAW,KACxCe,EAAQxB,OAASwB,EAAQxB,KAAO,WAE7BwB,EACX,CDW2Be,CAAsBf,GACzC9D,KAAK8E,UGpBb,SAA6BZ,EAASa,EAAWpE,GAAWqE,MAAEA,EAAQ,EAACjC,SAAEA,EAAW,IAAGkC,OAAEA,EAAS,EAACC,WAAEA,EAAa,OAAM5C,KAAEA,EAAO,UAAS6C,MAAEA,GAAW,CAAA,EAAIhB,GACvJ,MAAMiB,EAAkB,CACpBL,CAACA,GAAYpE,GAEbwE,IACAC,EAAgBC,OAASF,GAC7B,MAAMtD,EAASiB,EAAwBR,EAAMS,GAIzCS,MAAMC,QAAQ5B,KACduD,EAAgBvD,OAASA,GAI7B,MAAMiC,EAAU,CACZkB,QACAjC,WACAlB,OAAS2B,MAAMC,QAAQ5B,GAAmB,SAATA,EACjCyD,KAAM,OACNC,WAAYN,EAAS,EACrBO,UAA0B,YAAfN,EAA2B,YAAc,UAUxD,OARIf,IACAL,EAAQK,cAAgBA,GACVD,EAAQvC,QAAQyD,EAAiBtB,EAOvD,CHZyB2B,CAAoBvB,EAASnD,EAAMJ,EAAW+D,EAAYP,IAC/C,IAAxBO,EAAWgB,UACX1F,KAAK8E,UAAUa,QAEnB3F,KAAK8E,UAAUc,SAAW,KAEtB,GADA5F,KAAKgE,aAAehE,KAAK6F,MACpB1B,EAAe,CAChB,MAAM2B,Eb9BtB,SAA0BnF,GAAWsE,OAAEA,EAAMC,WAAEA,EAAa,QAAUb,EAAe0B,EAAQ,GACzF,MAAMC,EAAoBrF,EAAUsF,OAAOrG,GAErCsG,EADmBH,EAAQ,GAAMd,GAAyB,SAAfC,GAAyBD,EAAS,GAAM,EACxD,EAAIe,EAAkBnF,OAAS,EAChE,OAAQqF,QAA2BrH,IAAlBwF,EAEXA,EADA2B,EAAkBE,EAE5B,CauBiCC,CAAiBxF,EAAWX,KAAK8D,QAASO,EAAerE,KAAK+F,OAC3E/F,KAAKoG,kBACLpG,KAAKoG,kBAAkBN,GI/B3C,SAAkB5B,EAASnD,EAAMlB,GAC7BiB,EAASC,GACHmD,EAAQmC,MAAMC,YAAYvF,EAAMlB,GAC/BqE,EAAQmC,MAAMtF,GAAQlB,CACjC,CJkCoB0G,CAASrC,EAASnD,EAAM+E,GAE5B9F,KAAK8E,UAAU0B,QAClB,CACDlC,MACAtE,KAAKM,iBAEZ,CACD,IAAAmG,GACQzG,KAAKiE,YAETjE,KAAK8E,UAAU2B,OACI,aAAfzG,KAAK0G,OACL1G,KAAKC,iBAEZ,CACD,KAAA0F,GACI3F,KAAK8E,UAAUa,OAClB,CACD,QAAAgB,GACI3G,KAAK8E,UAAU8B,UAClB,CACD,MAAAJ,GACI,IACIxG,KAAK8E,UAAU0B,QAClB,CACD,MAAO1E,GAAM,CAChB,CACD,IAAA+E,GACI,GAAI7G,KAAKiE,UACL,OACJjE,KAAKiE,WAAY,EACjB,MAAMyC,MAAEA,GAAU1G,KACJ,SAAV0G,GAA8B,aAAVA,IAGpB1G,KAAKoG,kBACLpG,KAAKoG,oBAGLpG,KAAK8G,eAEJ9G,KAAKuE,iBACNvE,KAAKwG,SACZ,CAaD,YAAAM,GACS9G,KAAKuE,iBACNvE,KAAK8E,UAAUgC,gBAEtB,CACD,YAAI/D,GACA,MAAMA,EAAW/C,KAAK8E,UAAUiC,QAAQC,sBAAsBjE,UAAY,EAC1E,OAAOrD,EAAsBuH,OAAOlE,GACvC,CACD,qBAAImE,GACA,MAAMlC,MAAEA,EAAQ,GAAMhF,KAAK8D,SAAW,CAAA,EACtC,OAAO9D,KAAK+C,SAAWrD,EAAsBsF,EAChD,CACD,QAAIa,GACA,OAAOnG,EAAsBuH,OAAOjH,KAAK8E,UAAUqC,cAAgB,EACtE,CACD,QAAItB,CAAKuB,GACLpH,KAAKgE,aAAe,KACpBhE,KAAK8E,UAAUqC,YAAc3H,EAAsB4H,EACtD,CAKD,SAAIrB,GACA,OAAO/F,KAAK8E,UAAUuC,YACzB,CACD,SAAItB,CAAMuB,GAEFA,EAAW,IACXtH,KAAKgE,aAAe,MACxBhE,KAAK8E,UAAUuC,aAAeC,CACjC,CACD,SAAIZ,GACA,OAA6B,OAAtB1G,KAAKgE,aACN,WACAhE,KAAK8E,UAAUyC,SACxB,CACD,aAAIC,GACA,OAAOP,OAAOjH,KAAK8E,UAAU0C,UAChC,CACD,aAAIA,CAAUC,GACVzH,KAAK8E,UAAU0C,UAAYC,CAC9B,CAID,cAAAC,EAAeC,SAAEA,EAAQC,QAAEA,IAKvB,OAJI5H,KAAKoE,cACLpE,KAAK8E,UAAUiC,QAAQc,aAAa,CAAEhG,OAAQ,WAElD7B,KAAK8E,UAAUc,SAAW,KACtB+B,GAAY1G,KACZjB,KAAK8E,UAAU6C,SAAWA,EACnBrI,GAGAsI,EAAQ5H,KAEtB,EK5JL,MAAM8H,EACF,WAAA/H,CAAYgI,GAER/H,KAAK6G,KAAO,IAAM7G,KAAKgI,OAAO,QAC9BhI,KAAK+H,WAAaA,EAAW9B,OAAOzB,QACvC,CACD,YAAItE,GACA,OAAOE,QAAQ6H,IAAIjI,KAAK+H,WAAWpE,IAAKmB,GAAcA,EAAU5E,UACnE,CAID,MAAAgI,CAAOC,GACH,OAAOnI,KAAK+H,WAAW,GAAGI,EAC7B,CACD,MAAAC,CAAOD,EAAUE,GACb,IAAK,IAAIzH,EAAI,EAAGA,EAAIZ,KAAK+H,WAAWlH,OAAQD,IACxCZ,KAAK+H,WAAWnH,GAAGuH,GAAYE,CAEtC,CACD,cAAAX,CAAeC,GACX,MAAMW,EAAgBtI,KAAK+H,WAAWpE,IAAKmB,GAAcA,EAAU4C,eAAeC,IAClF,MAAO,KACHW,EAAcC,QAAQ,CAAC/B,EAAQ5F,KAC3B4F,GAAUA,IACVxG,KAAK+H,WAAWnH,GAAGiG,SAG9B,CACD,QAAIhB,GACA,OAAO7F,KAAKkI,OAAO,OACtB,CACD,QAAIrC,CAAKA,GACL7F,KAAKoI,OAAO,OAAQvC,EACvB,CACD,SAAIE,GACA,OAAO/F,KAAKkI,OAAO,QACtB,CACD,SAAInC,CAAMA,GACN/F,KAAKoI,OAAO,QAASrC,EACxB,CACD,SAAIW,GACA,OAAO1G,KAAKkI,OAAO,QACtB,CACD,aAAIV,GACA,OAAOxH,KAAKkI,OAAO,YACtB,CACD,YAAInF,GACA,OAAOyF,EAAOxI,KAAK+H,WAAY,WAClC,CACD,qBAAIb,GACA,OAAOsB,EAAOxI,KAAK+H,WAAY,oBAClC,CACD,MAAAC,CAAOS,GACHzI,KAAK+H,WAAWQ,QAASG,GAAaA,EAASD,KAClD,CACD,IAAAhC,GACIzG,KAAKgI,OAAO,OACf,CACD,KAAArC,GACI3F,KAAKgI,OAAO,QACf,CACD,MAAAxB,GACIxG,KAAKgI,OAAO,SACf,CACD,QAAArB,GACI3G,KAAKgI,OAAO,WACf,EAEL,SAASQ,EAAOT,EAAYI,GACxB,IAAI/E,EAAM,EACV,IAAK,IAAIxC,EAAI,EAAGA,EAAImH,EAAWlH,OAAQD,IAAK,CACxC,MAAMf,EAAQkI,EAAWnH,GAAGuH,GACd,OAAVtI,GAAkBA,EAAQuD,IAC1BA,EAAMvD,EAEb,CACD,OAAOuD,CACX,CC5EA,MAAMuF,UAA+Bb,EACjC,IAAAvH,CAAKC,EAAWoI,GACZ,OAAO5I,KAAKE,SAAS2I,QAAQrI,GAAWD,KAAK,OAChD,ECLL,MAAMuI,EAAgB,IAAIC,QACpBC,EAAkB,CAACjI,EAAMoD,EAAgB,KAAO,GAAGpD,KAAQoD,IACjE,SAAS8E,EAAgB/E,GACrB,MAAMP,EAAMmF,EAAcI,IAAIhF,IAAY,IAAIiF,IAE9C,OADAL,EAAcM,IAAIlF,EAASP,GACpBA,CACX,CCNA,SAAS0F,EAAmB3E,EAAY4E,GACpC,OAAQ5E,IAAa4E,IACjB5E,GAAsB,SACtBA,CACR,CCJA,MAAM6E,EAAW,IAAIC,IAAI,CAErB,cACA,iBACA,mBACA,oBACA,kBACA,eACA,SACA,sBACA,uBACA,0BACA,yBAEA,QACA,WACA,SACA,YACA,MACA,QACA,SACA,OACA,QACA,aACA,kBACA,gBACA,cACA,mBACA,iBAEA,UACA,aACA,eACA,gBACA,cACA,eACA,oBACA,kBACA,gBACA,qBACA,mBACA,SACA,YACA,cACA,eACA,aACA,cACA,mBACA,iBACA,eACA,oBACA,kBAEA,sBACA,wBCpDJ,SAASC,EAAgB9I,EAAWI,GAChC,IAAK,IAAIH,EAAI,EAAGA,EAAID,EAAUE,OAAQD,IACN,iBAAjBD,EAAUC,IAAmB2I,EAASG,IAAI3I,KACjDJ,EAAUC,GAAKD,EAAUC,GAAK,KAG1C,CCNA,SAAS+I,EAAiBzF,EAASnD,GAC/B,MAAM6I,EAAgB1I,OAAOyI,iBAAiBzF,GAC9C,OAAOpD,EAASC,GACV6I,EAAcC,iBAAiB9I,GAC/B6I,EAAc7I,EACxB,CCLO,SAAS+I,EAAgBC,EAAmBpJ,EAAWmD,EAASkG,GACnE,MAAMC,ECHV,SAAyBF,EAAmBC,GACxC,GAAID,aAA6BG,YAC7B,MAAO,CAACH,GAEP,GAAiC,iBAAtBA,EAAgC,CAC5C,IAAII,EAAO1I,SACPuI,IACAG,EAAOH,EAAMI,SAEjB,MAAMH,EACFE,EAAKE,iBAAiBN,GAC1B,OAAOE,EAAWzG,MAAM8G,KAAKL,GAAY,EAC5C,CACD,OAAOzG,MAAM8G,KAAKP,EACtB,CDXqBQ,CAAgBR,EAAmBC,GAC9CQ,EAAcP,EAASpJ,OAC7BpC,EAAU+F,QAAQgG,GAAc,8BAA+B,qBAkB/D,MAAMC,EAAuB,GAI7B,IAAK,IAAI7J,EAAI,EAAGA,EAAI4J,EAAa5J,IAAK,CAClC,MAAMsD,EAAU+F,EAASrJ,GACnB8J,EAAoB,IAAK5G,GAIQ,mBAA5B4G,EAAkB1F,QACzB0F,EAAkB1F,MAAQ0F,EAAkB1F,MAAMpE,EAAG4J,IAEzD,IAAK,MAAMzF,KAAapE,EAAW,CAC/B,IAAIgK,EAAiBhK,EAAUoE,GAC1BvB,MAAMC,QAAQkH,KACfA,EAAiB,CAACA,IAEtB,MAAMC,EAAe,IACdvB,EAAmBqB,EAAmB3F,IAE7C6F,EAAa7H,WAAa6H,EAAa7H,SAAWvD,EAAsBoL,EAAa7H,WACrF6H,EAAa5F,QAAU4F,EAAa5F,MAAQxF,EAAsBoL,EAAa5F,QAK/E,MAAMrB,EAAMsF,EAAgB/E,GACtBoF,EAAMN,EAAgBjE,EAAW6F,EAAazG,eAAiB,IAC/D0G,EAAmBlH,EAAIuF,IAAII,GACjCuB,GAAoBA,EAAiBhE,OACrC4D,EAAqBK,KAAK,CACtBnH,MACA2F,MACAyB,oBAAqBJ,EACrB7G,QAAS,IACF8G,EACH1G,UACAnD,KAAMgE,EACNX,cAAesG,EAAkBjG,OAASiG,EAAkBpI,OAGvE,CACJ,CAID,IAAK,IAAI1B,EAAI,EAAGA,EAAI6J,EAAqB5J,OAAQD,IAAK,CAClD,MAAMmK,oBAAEA,EAAqBjH,QAASkH,GAAqBP,EAAqB7J,IAC1EsD,QAAEA,EAAOnD,KAAEA,EAAIoD,cAAEA,GAAkB6G,EACpC7G,GAA4C,OAA3B4G,EAAoB,KACtCA,EAAoB,GAAKpB,EAAiBzF,EAASnD,IAEvDL,EAAcqK,GACdtB,EAAgBsB,EAAqBhK,IAOhCoD,GAAiB4G,EAAoBlK,OAAS,GAC/CkK,EAAoBE,QAAQtB,EAAiBzF,EAASnD,IAE1DiK,EAAiBrK,UAAYoK,CAChC,CAID,MAAMhD,EAAa,GACnB,IAAK,IAAInH,EAAI,EAAGA,EAAI6J,EAAqB5J,OAAQD,IAAK,CAClD,MAAM+C,IAAEA,EAAG2F,IAAEA,EAAKxF,QAASkH,GAAqBP,EAAqB7J,GAC/DkE,EAAY,IAAIjB,EAAgBmH,GACtCrH,EAAIyF,IAAIE,EAAKxE,GACbA,EAAU5E,SAAS2I,QAAQ,IAAMlF,EAAIuH,OAAO5B,IAC5CvB,EAAW+C,KAAKhG,EACnB,CACD,OAAOiD,CACX,CEnGY,MAACoD,EAA4BnB,GACrC,SAAuBD,EAAmBpJ,EAAWmD,GACjD,OAAO,IAAI6E,EAAuBmB,EAAgBC,EAAmBpJ,EAAWmD,EAASkG,GAC5F,EAGQoB,EAA4BD"}